# Начало работы с Docker-compose.yml
Загружаем необходимые файлы. Если ранее подгружали эти файлы в другие контейнера, то возникнет ошибка. Решение: удалить старые контейнера, либо изменить название

```
docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:8.0.31
запускаем команду и даем ей имя some-mysql -е передаем переменную окружения, она будет доступна изнутри контейнера 
будет доступна по MYSQL_ROOT_PASSWORD my-secret-pw это пароль mysql:8.0.31 образ:версия 

docker run --name myphp -d --link some-mysql:db -p 8081:80 phpmyadmin/phpmyadmin
Запускаем команду, даем ей имя myphp в режиме deamon настраиваем связь ссылки some-mysql у которой будет имя db
-р это проброс портов до : порт локальной машины, после порт контейнера т.е. порт 80 привязывается к порту 8081
phpmyadmin/phpmyadmin это имя пользователя/имя репозитория 

```

заходим в браузер и пишем в поисковике 127.0.0.1:8081 
перекидывает на сайт вводим логин root и пароль my-secret-pw

Создаем директорию и переходим в нее 
```
mkdir sem5 
cd sem5
```
Создаем docker-compose.yml и редактируем 
```
touch docker-compose.yml
nano docker-compose.yml
```
Заполняем файл

### Первый сервис 
```
# Указываем версию синтаксиса файла docker-compose
version: '3.1'
# Описываем сервисы, которые будут запущены
services:
  # Первый сервис: MySQL сервер
  some-mysql:
    # Используемый Docker образ
    image: mysql:8.0.31
    # Переменные окружения для MySQL
    environment:
      MYSQL_ROOT_PASSWORD: my-secret-pw
    # Монтируем том для сохранения данных MySQL
    volumes:
      - mysql_data:/var/lib/mysql
```
 ### Второй сервис: phpMyAdmin
 ```
  myphp:
    # Используемый Docker образ
    image: phpmyadmin/phpmyadmin
    # Проброс портов: хост:контейнер
    ports:
      - 8081:80
    # Указываем зависимость от MySQL сервиса
    depends_on:
      - some-mysql
    # Переменные окружения для phpMyAdmin
    environment:
      PMA_HOST: some-mysql
```

*ВАЖНО: Для сохранения данных при уничтожении контейнера нужно прописывать volumes
Данные базы данных сохраняются в папку lib/mysql 

После запускаем файл
```
docker-compose up -d 
```
Для просмотра контейнеров
``` 
docker-compose ps
```
## Чистка памяти
ncdu для чистки памяти 
sudo ncdu /

Удаление sudo apt remove --purge *папку которую хоти удалить

sudo apt-get remove --purge lxc lxc-templates
sudo apt-get autoremove
sudo apt-get clean
sudo apt-get autoclean

## Для работы с java (семинар 4)

Для работы с джава написание в терминал кода в докере
#### Используем официальный базовый образ Java 11
FROM openjdk:11-jre-slim

#### Устанавливаем рабочую директорию внутри контейнера
WORKDIR /app

#### Копируем JAR-файл вашего приложения в рабочую директорию контейнера
COPY ./your-app.jar /app/your-app.jar

#### Указываем команду для запуска приложения
CMD ["java", "-jar", "/app/your-app.jar"]

Поиск образов и информации docker hub 

## Пояснение команд 

1. version: Указывает версию синтаксиса файла docker-compose. Это нужно для корректного чтения файла Docker Compose.

2. services: Секция, в которой определяются все контейнеры, которые должны быть запущены.

3. some-mysql: Имя первого сервиса, запускающего MySQL.

4. image: Docker образ, который будет использован для этого контейнера.

5. environment: Переменные окружения для контейнера. В данном случае, устанавливаем пароль root пользователя MySQL.

6. volumes: Здесь мы монтируем том для сохранения данных MySQL. Это нужно для сохранения данных между перезапусками контейнера.

7. myphp: Имя второго сервиса, запускающего phpMyAdmin.

8. depends_on: Указывает, что данный сервис зависит от some-mysql, и нужно сначала его запустить.

9. PMA_HOST: Указывает на имя хоста MySQL сервера, к которому должен подключиться phpMyAdmin. Здесь это имя сервиса some-mysql.

10. volumes: В этой секции описываются тома, которые будут использованы. В данном случае, это mysql_data для MySQL.

Этот файл делает то же, что и команды docker run, но в более удобном и управляемом формате. 

## Docker-swarm 
Docker-swarm это объединение docker deamon на нескольких серверах в единую сеть и с помощью этого можно использовать не только локального демона но и всех других

При объединение демонов в docker swarm дает возможность одному демоному взаимодействовать на другого. 
Сущность одного демона распространены на несколько компьютеров. И команды попадают в это сущность. Если процесс не запущен, то сущность увидит это и запустит на другой машине.
Если один комп выходит из работы, другие могут его заменить. 



